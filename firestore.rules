rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    // Helper function to check if the authenticated user's email matches the profile email
    function isEmailMatch(userId) {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(userId)) && 
             'email' in get(/databases/$(database)/documents/users/$(userId)).data && 
             request.auth.token.email == get(/databases/$(database)/documents/users/$(userId)).data.email;
    }
    
    // Helper function to check if user is either the owner or has matching email
    function isOwnerOrEmailMatch(userId) {
      return isOwner(userId) || isEmailMatch(userId);
    }

    function hasRole(role) {
      return isAuthenticated() && getUserData().role == role;
    }

    function isAdmin() {
      return hasRole('admin');
    }

    function isTreasurer() {
      return hasRole('treasurer');
    }

    function isEditor() {
      return hasRole('editor');
    }
    
    function isViewer() {
      return hasRole('viewer');
    }

    function isAdminOrTreasurer() {
      return isAdmin() || isTreasurer();
    }

    function canEdit() {
      return isAdmin() || isTreasurer() || isEditor();
    }

    // User profiles with role-based permissions and email authentication
    match /users/{userId} {
      // Allow create only for admins or if it's the user's own initial profile
      // Ensure email field is set to the authenticated user's email when creating own profile
      allow create: if isAuthenticated() && (
        isAdmin() || 
        (request.auth.uid == userId && request.resource.data.email == request.auth.token.email)
      );
      
      // Role-based read permissions:
      // - Admins and treasurers can read all user profiles
      // - Editors can read all user profiles
      // - Viewers can only read their own profile (by UID or email match)
      allow read: if isAuthenticated() && (
        isAdmin() || 
        isTreasurer() || 
        isEditor() || 
        (isViewer() && isOwnerOrEmailMatch(userId))
      );
      
      // Role-based update permissions:
      // - Admins can update any profile and all fields
      // - Treasurers can update any profile except admin profiles
      // - Editors can update viewer profiles only
      // - All users can update their own profile (by UID or email match) except the role field
      // - Email field can only be updated to match the authenticated user's email
      allow update: if isAuthenticated() && (
        isAdmin() || 
        (isTreasurer() && !('role' in resource.data && resource.data.role == 'admin')) ||
        (isEditor() && 'role' in resource.data && resource.data.role == 'viewer') ||
        (isOwnerOrEmailMatch(userId) && 
          request.resource.data.diff(resource.data).affectedKeys().hasNone(['role']) &&
          (!('email' in request.resource.data) || request.resource.data.email == request.auth.token.email))
      );
      
      // Only admins can delete user profiles, if needed
      allow delete: if isAuthenticated() && isAdmin();
      
      // Validate that email field matches the authenticated user's email when creating/updating own profile
      function isValidEmailField() {
        return request.resource.data.email == request.auth.token.email;
      }
    }

    // User's private data (transactions, members, etc.)
    match /users/{userId}/{collection}/{document} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId) && canEdit();
      allow update: if isOwner(userId) && canEdit();
      allow delete: if isOwner(userId) && isAdminOrTreasurer();
    }

    // Nested subcollections
    match /users/{userId}/{collection}/{document}/{subcollection}/{subdoc} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId);
    }

    // Announcements collection
    match /announcements/{announcementId} {
      // Allow read if user is authenticated
      allow read: if isAuthenticated();
      
      // Allow create/update/delete only for admins and editors
      allow create: if isAdmin() || isEditor();
      allow update: if isAdmin() || isEditor();
      allow delete: if isAdmin();
      
      // Additional validation for announcement data
      function isValidAnnouncement() {
        return request.resource.data.keys().hasAll([
          'title',
          'message',
          'audience',
          'priority',
          'status'
        ]) &&
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.title.size() <= 200 &&
        request.resource.data.message is string &&
        request.resource.data.message.size() > 0 &&
        request.resource.data.audience in ['all', 'members', 'specific'] &&
        request.resource.data.priority in ['low', 'medium', 'high'] &&
        request.resource.data.status in ['draft', 'published', 'archived'];
      }
      
      // Validate announcement data on create and update
      allow create: if isValidAnnouncement() && 
                   request.resource.data.createdBy == request.auth.uid &&
                   request.resource.data.createdAt == request.time;
                   
      allow update: if (
        // Existing data
        resource.data.createdBy == request.auth.uid || isAdmin()
      ) && (
        // Only allow certain fields to be updated
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['title', 'message', 'audience', 'priority', 'status', 'scheduledFor', 'updatedAt', 'updatedBy'])
      ) && (
        // Validate the updated data
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.title.size() <= 200 &&
        request.resource.data.message is string &&
        request.resource.data.message.size() > 0 &&
        request.resource.data.audience in ['all', 'members', 'specific'] &&
        request.resource.data.priority in ['low', 'medium', 'high'] &&
        request.resource.data.status in ['draft', 'published', 'archived'] &&
        request.resource.data.updatedAt == request.time
      );
    }
  }
}
